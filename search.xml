<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6--promise]]></title>
    <url>%2FES6-promise%2F</url>
    <content type="text"><![CDATA[本文摘自 阮一峰 的 Promise 对象。想要了解更多请访问原文。Promise 是异步编程的一种解决方案，ES6 将其写进了语言标准，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象的特点 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的优缺点 优点： 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 提供统一的接口，使得控制异步操作更加容易。 缺点 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法创建实例 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是， 将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject 函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。123456789const myPromise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 指定回调函数Promise实例生成以后，可以用 then 方法分别指定resolved状态和rejected状态的回调函数。then方法可以接受两个回调函数作为参数: 第一个回调函数是Promise对象的状态变为resolved时调用， 第二个回调函数是Promise对象的状态变为rejected时调用，可选，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例。123456789101112131415161718myPromise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);// 示例function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done');// setTimeout的第三个参数开始，是传给执行函数（在本例中是 resolve）的其他参数 &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);// 输出 'done'&#125;); 简单示例 promise 新建后立即执行，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。 123456789101112131415let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// 输出结果依次为：PromiseHi!resolved. 异步加载图片 1234567891011121314151617181920function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125;loadImageAsync('aaa.jpg').then(function(img)&#123; console.log(img)&#125;)// 图片url正确时：输出 &lt;img src="aaa.jpg"&gt;// 图片url错误时：输出 VM2675:10 Uncaught (in promise) Error: Could not load image at aaa.jpg at Image.image.onerror 用Promise对象实现 Ajax 操作 123456789101112131415161718192021222324252627282930// XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 调用resolve或reject并不会终结 Promise 的参数函数的执行，但是不提倡这种做法，原因如下：一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 输出结果为：//2//1// 调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 常用方法Promise.prototype.then()作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 1234567getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;);// 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。 下面的三种写法都是等价的： 12345678910111213141516171819202122232425262728// 写法一：const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test// 写法二const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法三const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 一些注意点： 如果 Promise 状态已经变成resolved，再抛出错误不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。因为这样可以可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch） 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。即Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 其他方法 Promise.all()：可以并行执行不同的promise，并在所有的promise执行完成后执行then。 12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;); Promise.race()：可以并行执行不同的promise，获得先返回的结果。常用于多个异步任务的容错 123456789var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // 'P1'&#125;);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰js教程读后记录]]></title>
    <url>%2F%E5%BB%96%E9%9B%AA%E5%B3%B0js%E6%95%99%E7%A8%8B%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文主要记录在学习廖雪峰的js教程之后，发现的一些容易忽略或是之前不知道的知识。 关于比较运算符 NaN这个特殊的Number与所有其他值都不相等，包括它自己。唯一能判断NaN的方法是通过isNaN()函数。 123NaN == NaN // falseNaN === NaN // falseisNaN(NaN) // true 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值 121 / 3 === (1 - 2 / 3); // falseMath.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 关于动态语言和静态语言 变量本身类型不固定的语言称之为动态语言。eg:javascript 12var a = 123; // a的值是整数123a = 'ABC'; // a变为字符串 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。eg:java 12int a = 123; // a是整数类型变量，类型用int申明a = "ABC"; // 错误：不能把字符串赋给整型变量 关于对象 删除对象的某个属性：使用 delete 1234567var obj = &#123; name:'hm', age:10, kind:'shop'&#125;delete obj.kindconsole.log(obj.kind) // undefined 检测某个对象是否拥有某一属性：使用 in 。但是使用in判断一个属性存在，这个属性不一定是该对象的，它可能是继承得到的 123console.log('name' in obj) // trueconsole.log('toString' in obj) // true// toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以obj也拥有toString属性 判断一个属性是否是某个对象自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法 12console.log(obj.hasOwnProperty('name')) // trueconsole.log(obj.hasOwnProperty('toString')) // false 关于 for…of 和 for…in 的区别 for…in循环，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 1234567var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125;// 此处输出的是索引和属性名// for ... in循环将把name包括在内，但Array的length属性却不包括在内 for…of循环，只循环集合本身的元素 123456var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125;// 此处输出的是元素 关于 reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 12345678910111213141516171819202122232425262728293031323334// reduce 求和var arr = [1, 3, 5, 7, 9];var res = arr.reduce(function (x, y) &#123; return x + y;&#125;); console.log(res) // 25// 另一个用法示例var arr_1 = [1, 3, 5, 7, 9];var res_1 = arr_1.reduce(function (x, y) &#123; return x * 10 + y;&#125;)console.log(res_1) // 13579// 练习1：使用 map 和 reduce：字符串 '13579' 先变成Array——[1, 3, 5, 7, 9]，再利用reduce()把字符串转换为Number。function strToNum(s)&#123; var temp = s.split(''); temp = temp.map(function(v)&#123; return v * 1; &#125;) // 这一步骤是为了把数组中的元素从字符串类型变为数值型 return temp.reduce(funcyion(x,y)&#123; return x * 10 + y; &#125;)&#125;// 练习2：利用map()把数组中的字符串变成整数var arr = ['10', '10', '10'];// 错误写法var r = arr.map(parseInt); // 这种写法达不到想要的效果，最终输出结果为 1，NaN，NaN。原因是：Array.prototype.map传递3个参数：元素、索引、数组，parseInt接收前两个参数，造成混乱// 等同于：r[0] = parseInt('10',0)---输出10;r[1] = parseInt('10',1)---输出NaN;r[2] = parseInt('10',2)---输出2( '10' 对应的二进制是2)// 正确输出var r_1 = arr.map(v =&gt; parseInt(v)); 利用 filter 进行数组去重可结合 indexOf() 进行去重，因为 indexOf 总是返回元素第一次出现的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被filter滤掉了 1234567891011121314151617181920212223var arr = ['apple','pear','orange','apple','banana','banana'];var r = arr.filter(function(ele,index,self)&#123; return self.indexOf(ele) === index;&#125;)console.log(r)'use strict';function get_primes(arr) &#123; return r = arr.filter(function (num) &#123; if ( num === 1) &#123; return false ; &#125; if ( num === 2||num === 3) &#123;return num ;&#125; // 不在6的倍数两侧的一定不是质数 if (num % 6 != 1 &amp;&amp; num % 6 != 5) &#123;return false;&#125; var sqrt = Math.sqrt(num); for (let i = 5; i &lt;= sqrt; i += 6) &#123; if (num % i == 0 || num % (i + 2) == 0) &#123;return false;&#125; &#125; return num; &#125;&#125; 关于 typeoftypeof操作符可以判断出number、boolean、string、function和undefined。 用typeof检测类型时需注意，null的类型是object，Array的类型也是object 1234567891011121314typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof &#123;&#125;; // 'object' 关于 JSON.stringfy()的参数在向服务器发送数据时一般是字符串。JSON.stringify() 方法将 JavaScript 对象转换为字符串。JSON.stringify()可以有三个参数： value:必需， 要转换的 JavaScript 值（通常为对象或数组）。 replacer:可选。用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space:可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']&#125;;// 添加空格进行缩进console.log(JSON.stringify(xiaoming, null, ' ');)/*输出结果为：&#123; "name": "小明", "age": 14, "gender": true, "height": 1.65, "grade": null, "middle-school": "\"W3C\" Middle School", "skills": [ "JavaScript", "Java", "Python", "Lisp" ]&#125;*/// 输出指定的属性console.log(JSON.stringify(xiaoming, ['name', 'age']);) // &#123;"name": "小明","age": 14&#125;// 传入函数function convert(key, value) &#123; // 把所有属性值变为大写 if (typeof value === 'string') &#123; return value.toUpperCase(); &#125; return value;&#125;console.log(JSON.stringify(xiaoming, convert, ' '));/*输出结果为：&#123; "name": "小明", "age": 14, "gender": true, "height": 1.65, "grade": null, "middle-school": "\"W3C\" MIDDLE SCHOOL", "skills": [ "JAVASCRIPT", "JAVA", "PYTHON", "LISP" ]&#125;*/// 神奇的 toJSON 命名的方法:给 xiaoming_2 定义一个toJSON()的方法，直接返回JSON应该序列化的数据var xiaoming_2 = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming_2); // '&#123;"Name":"小明","Age":14&#125;' 关于表单提交表单提交有两种方式： 通过&lt;form&gt;元素的submit()方法提交一个表单，例如，响应一个&lt;button&gt;的click事件，在JavaScript代码中提交表单 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 响应&lt;form&gt;本身的onsubmit事件，在提交form时作修改注意：在下面的示例中，要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form" onsubmit="return checkForm()"&gt; &lt;input type="text" name="test"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;&#125;&lt;/script&gt; 没有name属性的&lt;input&gt;的数据不会被提交 操作文件在HTML表单中，可以上传文件的唯一控件就是&lt;input type=”file”&gt; 注意：当一个表单包含&lt;input type=”file”&gt;时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;form method="post" action="" enctype="multipart/form-data"&gt; &lt;!-- 预览区域 --&gt; &lt;div id="test-image-preview" style="width:500px;height:300px;border:1px solid #ccc;"&gt;&lt;/div&gt; &lt;input type="file" id="test-image-file"&gt; &lt;div id="test-file-info"&gt;&lt;/div&gt;&lt;/form&gt;&lt;script&gt;var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview');// 监听change事件:fileInput.addEventListener('change', function () &#123; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); reader.onload = function(e) &#123;// 当文件读取完成后，自动调用此函数: var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件: reader.readAsDataURL(file);&#125;);&lt;/script&gt; 原生的ajax请求12345678910111213141516171819202122232425var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest();&#125; else &#123;// 对于低版本的IE，需要用ActiveXObject对象 request = new ActiveXObject('Microsoft.XMLHTTP');&#125;request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: console.log(request.responseText) &#125; else &#123; // 失败，根据响应码判断失败原因: console.log(request.status) &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;request.open('GET', '请求地址');// open有三个参数：1.指定请求方式：GET/POST；2.指定请求的url地址；3.指定是否使用异步，默认为truerequest.send();// 发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去 关于错误处理捕获错误使用try … catch … finally，catch和finally可以不必都出现。当代码块被try { … }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { … }包裹的代码就是错误处理代码，变量e表示捕获到的错误。如果没有出错，catch (e) { … }代码不会被执行。最后，无论有没有错误，finally一定会被执行。 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 123456789101112try &#123; s = prompt('请输入一个数字'); n = parseInt(s); if (isNaN(n)) &#123; throw new Error('输入错误'); &#125; // 计算平方: r = n * n; console.log(n + ' * ' + n + ' = ' + r);&#125; catch (e) &#123; console.log('出错了：' + e);&#125; 关于jquery版本问题目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8 prop()和attr()HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种（eg:checked），这种情况下两种方法返回值不同。也可用 is() 判断，返回值是布尔类型。 1234// &lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;var radio = $('#test-radio');radio.attr('checked'); // 'checked'radio.prop('checked'); // true 解除事件绑定12345678910111213141516// 正确写法function hello() &#123; alert('hello!');&#125;a.click(hello); setTimeout(function () &#123; a.off('click', hello);&#125;, 10000);// 错误写法：两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，off('click', function () &#123;...&#125;)无法移除已绑定的第一个匿名函数b.click(function () &#123; alert('hello!');&#125;);b.off('click', function () &#123; alert('hello!');&#125;); 事件触发条件事件的触发总是由用户操作引起的。例如change事件，用户在文本框输入时会触发，但是如果用JavaScript代码去改动文本框的值，将不会触发change事件。有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件。input.change()相当于input.trigger(‘change’)，它是trigger()方法的简写。 jquery扩展（编写jquery插件）编写原则： 给$.fn绑定函数，实现插件的代码逻辑； 插件函数最后要return this;以支持链式调用； 插件函数要有默认值，绑定在$.fn.&lt;pluginName&gt;.defaults上； 用户在调用时可传入设定值以便覆盖默认值。 注：对于默认值的处理，可使用jQuery提供的辅助方法$.extend(target, obj1, obj2, …)，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高 123456789101112$.fn.highlight = function (options) &#123; // 把默认值和用户传入的options合并到对象&#123;&#125;中并返回: var opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options); this.css('backgroundColor', opts.backgroundColor).css('color', opts.color); return this;&#125;// 设定默认值，如果此处不定义defaults，直接使用$.fn.highlight时会报错提示$.fn.highlight.defaults未定义$.fn.highlight.defaults = &#123; color: '#d85030', backgroundColor: '#fff8de'&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于console]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Econsole%2F</url>
    <content type="text"><![CDATA[Console 对象用于 JavaScript 调试。JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 Console 对象常见的两个用途： 1. 显示网页代码运行时的错误信息。 2. 提供了一个命令行接口，用来与网页代码互动。 console 对象有很多方法，仅列出以下常见的几种： console.log() 输出信息 console.info() 与 console.log() 作用一样 console.error() 输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。 console.warn() 输出警告信息 有时候我们会看到 console.log(‘%s’,arr);这种写法相对来说并不常见。 上面所列的几种方法都支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o） 占位符 作用 %s 字符串 %d 或 %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串。 12345678910111213141516console.log("%d年%d月%d日",2011,3,26);// 格式成可展开的的DOM，像在开发者工具Element面板那样可展开 console.log('%o',document.body.firstElementChild); // 像JS对象那样访问DOM元素，可查看DOM元素的属性 // 等同于console.dir(document.body.firstElementChild) console.log('%O',document.body.firstElementChild);// 输出带样式的文字console.log("%c红色20px文字","color: red; font-size: 20px"); /* 输出图片，由于 console 不能定义 img，因此用背景图片代替。此外，console 不支持 width 和 height，利用空格和 font-size 代替；还可以使用 padding 和 line-height 代替宽高。 */console.log("%c","background:url(https://static.runoob.com/images/runoob-logo.png) no-repeat;padding:50px 300px;line-height:120px"); 注：使用 %c 占位符时，对应的后面的参数必须是 CSS 语句，用来对输出内容进行 CSS 渲染。常见的输出方式有两种：文字样式、图片输出。 其他常见方法： console.dir() 查看对象的信息 console.dirxml() 用来显示网页的某个节点（node）所包含的html/xml代码。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--Map和Set]]></title>
    <url>%2FES6-Map%E5%92%8CSet%2F</url>
    <content type="text"><![CDATA[ES6中新增的数据结构：Map和Set。 MapMap数据结构是为了解决对象无法使用非字符串作为键而提出的数据结构，本质上讲，Map是一个二维数组，其中数组元素是只含有两个元素的数组，这两个元素按顺序分别为键和值。如var m = new Map([[x, 1], [y, 2]]);实际上，最常用的形式是把对象作为键，对象相关的信息作为值来存储在Map中。 初始化Map1var m = new Map(); 方法set(key,value)设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则进行覆盖更新，否则新生成。 12345678910111213// 1.对象作为键var map_1 = new Map();var obj = &#123;p1:'v1'&#125;;map_1.set(obj,'hello');console.log(map_1.get(obj));// 结果为 hello// 2.数组作为参数var map_2 = new Map([ ['name','cr'], ['age',18]]);console.log(map_2.get('name'));// 结果为 crconsole.log(map_2.get('age'));// 结果为 18 size返回Map结构的成员总数 1console.log('%s',map_2.size);// 结果为 2 get(key)读取key对应的键值，如果找不到key,则返回undefined 12console.log(map_2.get('name'));// 结果为 crconsole.log(map_2.get('sex'));// 结果为 undefined has(key)某个键是否存在Map数据结构中，返回布尔值 12console.log(map_2.has('name'));// 结果为 trueconsole.log(map_2.has('sex'));// 结果为 false delete(key)删除某个键，返回布尔值；如果删除的是不存在的key，返回false 12map_2.delete('sex') // falsemap_2.delete('age') //true clear()清除所有成员，没有返回值 12map_2.clear();console.log(map_2);// 结果为：Map(0) &#123;&#125; 遍历keys() — 遍历键名123456for (v of map_2.keys())&#123; console.log(v)&#125;// 输出结果为// name// age values() — 遍历值123456for (v of map_2.values())&#123; console.log(v)&#125;// 输出结果为// cr// 18 entries() — 遍历键值对123456for (v of map_2.entries())&#123; console.log(v)&#125;// 输出结果为// ['name','cr']// ['age',18] forEach(value,key,map) — 遍历Map的所有成员123456map_2.forEach(function(value, key, map) &#123; console.log("Key: %s, Value: %s", key, value);&#125;)// 输出结果为 // Key: name, Value: cr// Key: age, Value: 18 与js其他数据类型的转化Map 转 数组使用扩展运算符（…）可将map内的元素都展开的数组；或者使用Array.from() 注: Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例 123456789let map_3 = new Map();map_3.set('k1', 1);map_3.set('k2', 2);map_3.set('k3', 3);console.log([...map_3]);console.log(Array.from(map_3));// 输出结果均为： [['k1',1],['k2',2],['k3',3]] 数组 转 Map123456const map_4 = new Map([ ['name', 'Aissen'], ['age', 12]])console.log(map_4);// 结果为 &#123;"name" =&gt; "Aissen", "age" =&gt; 12&#125; Map 转 对象写一个转换函数，遍历map的所有元素，将元素的键和值作为对象属性名和值写入Object中。 1234567891011121314function mapToObj(map) &#123; let obj = Object.create(null); for (let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125;const map_5 = new Map() .set('k1', 1) .set(&#123;pa:1&#125;, 2);console.log(mapToObj(map_5))// 结果为：&#123; k1: 1, '[object Object]': 2 &#125; 对象 转 Map写一个转换函数，遍历Object，将属性名和值作为键值对写入Map 12345678910function objToMap(obj) &#123; let map = new Map(); for (let k of Object.keys(obj)) &#123; map.set(k, obj[k]); &#125; return map;&#125;console.log(objToMap(&#123;yes: true, no: false&#125;))// 结果为：&#123; 'yes' =&gt; true, 'no' =&gt; false &#125; Set类似于数组，但是成员的值都是唯一的，没有重复值。可用来去重。但是在 set 中，数字3和字符串’3’是不同的元素。注：Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。在 Set 内部，两个NaN是相等。另外，两个对象总是不相等的。 初始化Set1let set_1 = new Set(); 方法add(value)添加某值，返回Set结构本身 123456789let set_2 = new Set();set_2.add(1);set_2.add('1');set_2.add(2);set_2.add(2);console.log(set_2);// 结果为：&#123;1,'1',2&#125; size返回Set结构的成员总数 1console.log('%s',set_2.size);// 结果为 3 delete(value)删除某值，返回布尔值。如果删除的是不存在的key，返回false 12set_2.delete('1');// trueset_2.delete('222');// false has(value)检测Set的成员是否有这个值，返回布尔值 12set_2.has(1);// trueset_2.has('111');// false clear()清除所有成员，不返回值 12set_2.clear();console.log('%s',set_2.size);// 结果为 0 遍历与Map的遍历基本一致，此处不再赘述。 与 Map 的转化Map 转 Set12345678910111213function mapToSet(map) &#123; let set = new Set() for (let [k,v] of map) &#123; set.add([k, v]) &#125; return set;&#125;const map_6 = new Map() .set('k1', 1) .set(&#123;pa:1&#125;, 2);console.log(mapToSet(map_6))// 结果为：&#123;['k1',1],[&#123;pa:1&#125;,2]&#125; Set 转 Map1234567const set_3 = new Set([ ['foo', 1], ['bar', 2]]);const map_7 = new Map(set)console.log(map_7)// 结果为：&#123; 'foo' =&gt; 1, 'bar' =&gt; 2 &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常见兼容问题]]></title>
    <url>%2Fjs%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文总结一些常见的js在浏览器中的兼容问题以供参考。以下内容是在网上搜集资料整理而成，尊重原作者版权，由于资料来源不一，未写原作者及出处，敬请谅解。 获取浏览器宽高12345678910111213141516// 网页可见区域宽var winW = document.body.clientWidth || document.docuemntElement.clientWidth;// 网页可见区域高var winH = document.body.clientHeight || document.docuemntElement.clientHeight;// 以上为不包括边框的宽高，如果是offsetWidth或者offsetHeight的话包括边框// 整个网页的宽var winWW = document.body.scrollWidth || document.docuemntElement.scrollWidth;// 整个网页的高var winHH = document.body.scrollHeight || document.docuemntElement.scrollHeight;// 滚动条// 网页被卷去的高var scrollHeight = document.body.scrollTop || document.docuemntElement.scrollTop;// 网页左卷的距离var scrollLeft = document.body.scrollLeft || document.docuemntElement.scrollLeft; event事件问题123456789101112131415161718192021222324252627282930313233343536373839404142document.onclick = function(ev)&#123;//兼容写法； var e = ev || window.event; var mouseX = e.clientX;//鼠标X轴的坐标 var mouseY = e.clientY;//鼠标Y轴的坐标&#125;// event事件中的targetdocument.onmouseover = function(e)&#123; var e = e || window.event; var Target = e.target || e.srcElement;//获取target的兼容写法，后面的为IE var from = e.relatedTarget || e.formElement;//鼠标来的地方，同样后面的为IE var to = e.relatedTarget || e.toElement;//鼠标去的地方&#125;// 阻止冒泡document.onclick = function(e)&#123; var e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation();//W3C标准 &#125;else&#123; e.cancelBubble = true;//IE &#125;&#125;// 阻止默认事件document.onclick = function(e)&#123; var e = e || window.event; if (e.preventDefault) &#123; e.preventDefault();//W3C标准 &#125;else&#123; e.returnValue = 'false';//IE &#125;&#125;// 获取键盘按下的键值document.onkeydown = function(e)&#123; var theEvent = e || window.event; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; console.log('按下的是回车键'); &#125; &#125; 获取DOM节点123456789101112131415161718192021222324252627282930313233//DOM节点相关，主要兼容IE 6 7 8//获取下一个兄弟节点function nextnode(obj)&#123; if (obj.nextElementSibling) &#123; return obj.nextElementSibling; &#125; else&#123; return obj.nextSibling; &#125;;&#125;//获取上一个兄弟节点function prenode(obj)&#123; if (obj.previousElementSibling) &#123; return obj.previousElementSibling; &#125; else&#123; return obj.previousSibling; &#125;;&#125;//获取第一个子节点function firstnode(obj)&#123; if (obj.firstElementChild) &#123; return obj.firstElementChild;//非IE678支持 &#125; else&#123; return obj.firstChild;//IE678支持 &#125;;&#125;//获取最后一个子节点function lastnode(obj)&#123; if (obj.lastElementChild) &#123; return obj.lastElementChild;//非IE678支持 &#125; else&#123; return obj.lastChild;//IE678支持 &#125;;&#125; 通过类名获取元素1234567891011121314151617181920212223242526272829//通过类名获取元素document.getElementsByClassName('');//IE 6 7 8不支持；//这里可以定义一个函数来解决兼容问题// 1.全局获取，oClass为你想要查找的类名，没有“.”function byClass1(oClass)&#123; var tags=document.all?document.all:document.getElementsByTagName('*'); var arr=[]; for (var i = 0; i &lt; tags.length; i++) &#123; var reg=new RegExp('\\b'+oClass+'\\b','g'); if (reg.test(tags[i].className)) &#123; arr.push(tags[i]); &#125;; &#125;; return arr;//注意返回的也是数组，包含你传入的class所有元素；&#125;// 2.局部获取类名，parentID为你传入的父级IDfunction byClass2(parentID,oClass)&#123; var parent=document.getElementById(parentID); var tags=parent.all?parent.all:parent.getElementsByTagName('*'); var arr=[]; for (var i = 0; i &lt; tags.length; i++) &#123; var reg=new RegExp('\\b'+oClass+'\\b','g'); if (reg.test(tags[i].className)) &#123; arr.push(tags[i]); &#125;; &#125;; return arr;//注意返回的也是数组，包含你传入的class所有元素；&#125; 获取元素的非行间样式值：12345678//获取元素的非行间样式值function getStyle(object,oCss) &#123; if (object.currentStyle) &#123; return object.currentStyle[oCss];//IE &#125;else&#123; return getComputedStyle(object,null)[oCss];//除了IE &#125;&#125; 事件监听12345678910111213141516// 设置监听事件function addEvent(obj,type,fn)&#123;//添加事件监听，三个参数分别为 对象、事件类型、事件处理函数，默认为false if (obj.addEventListener) &#123; obj.addEventListener(type,fn,false);//非IE &#125; else&#123; obj.attachEvent('on' + type,fn);//IE,这里已经加上on，传参的时候注意不要重复加了 &#125;;&#125;// 删除事件监听function removeEvent(obj,type,fn)&#123; if (obj.removeEventListener) &#123; obj.removeEventListener(type,fn,false);//非IE &#125; else&#123; obj.detachEvent('on'+type,fn);//IE，这里已经加上on，传参的时候注意不要重复加了 &#125;;&#125; 鼠标的滚轮事件1234567891011121314151617//火狐中的滚轮事件document.addEventListener("DOMMouseScroll",function(event)&#123; if(event.detail == -3)&#123; console.log('前滚') &#125;else if(event.detail == 3)&#123; console.log('后滚') &#125;&#125;,false)//非火狐中的滚轮事件document.onmousewheel = function(event)&#123; if(event.detail == 120)&#123; console.log('前滚') &#125;else if(event.detail == -120)&#123; console.log('后滚') &#125;&#125; console在IE下报错报错原因：在IE下没打开IE浏览器控制台的情况下是没有console对象的。 123456// 使用时需自行定义window.console = window.console || (function () &#123; var c =&#123;&#125;; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile= c.clear = c.exception = c.trace = c.assert = function()&#123;&#125;; return c;&#125;)(); ajax请求不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。eg：IE 浏览器使用 ActiveXObject 来创建，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象来创建。 12345678910111213141516171819202122//浏览器支持代码function ajaxFunction() &#123; var ajaxRequest; // 声明一个ajaxRequest变量，用来保存XMLHttpRequest 对象 try &#123; // 兼容：Opera 8.0+, Firefox, Safari ajaxRequest = new XMLHttpRequest(); //创建XMLHttpRequest 对象 &#125; catch (e) &#123; // 兼容：Internet Explorer 浏览器 try &#123; ajaxRequest = new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; try &#123; ajaxRequest = new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; // 出了问题时 alert("您的浏览器不支持Ajax！"); return false; &#125; &#125; &#125;&#125; IE6/7 不支持 JSON.parse和JSON.stringify123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if(!window.JSON)&#123; window.JSON = &#123; parse: function(sJson)&#123; return eval("(" + sJSON + ")"); &#125;, stringify: function(obj)&#123; var result = ""; for(var key in obj)&#123; if(typeof obj[key] == "string")&#123; // 如果属性值是String类型，属性值需要加上双引号 result += "\"" + key + "\":\"" + obj[key] + "\","; &#125;else if(obj[key] instanceof RegExp)&#123; // 如果属性是正则表达式，属性值只保留一对空大括号&#123;&#125; result += "\"" + key + "\":&#123;&#125;,"; &#125;else if(typeof obj[key] == "undefined" || obj[key] instanceof Function)&#123; // 如果属性值是undefined, 该属性被忽略。忽略方法。 &#125;else if(obj[key] instanceof Array)&#123; // 如果属性值是数组 result += "\"" + key + "\":["; var arr = obj[key]; for(var item in arr)&#123; if(typeof arr[item] == "string")&#123; // 如果数组项是String类型，需要加上双引号 result += "\"" + arr[item] + "\","; &#125;else if(arr[item] instanceof RegExp)&#123; // 如果属数组项是正则表达式，只保留一对空大括号&#123;&#125; result += "&#123;&#125;,"; &#125;else if(typeof arr[item] == "undefined" || arr[item] instanceof Function)&#123; // 如果数组项是undefined, 则显示null。如果是函数，则显示null?。 result += null +","; &#125;else if(arr[item] instanceof Object)&#123; //如果数组项是对象(非正则，非函数，非null)，调用本函数处理 result += this.stringify(arr[item]) +","; &#125;else&#123; result += arr[item] + ","; &#125; &#125; result = result.slice(0,-1)+"]," &#125;else if(obj[key] instanceof Object)&#123; // 如果属性值是对象(非null，非函数，非正则)，调用本函数处理 result += "\"" + key + "\":" + this.stringify(obj[key]) + ","; &#125;else&#123; result += "\"" + key + "\":" + obj[key] + ","; &#125; &#125; // 去除最后一个逗号,两边加&#123;&#125; return "&#123;" + result.slice(0,-1) + "&#125;"; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker初接触]]></title>
    <url>%2Ffreemarker%E5%88%9D%E6%8E%A5%E8%A7%A6%2F</url>
    <content type="text"><![CDATA[FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。模板编写为FreeMarker Template Language (FTL)。本文仅从个人工作中遇到的问题出发加以整理，不全之处敬请谅解。 FreeMarker模板文件主要由如下4个部分组成: 文本:直接输出的部分 注释: &lt;#– … –&gt; 格式部分,不会输出 插值:即 ${…} 或 #{…} 格式的部分,将使用数据模型中的部分替代输出 FTL指令:FreeMarker指定,和HTML标记类似,名字前加 # 予以区分,不会输出 定义变量1&lt;#assign name = &apos;cr&apos;/&gt; 插值的使用通用插值 字符串型 123&lt;div class="name"&gt; 姓名：$&#123;name&#125;&lt;/div&gt; 数字型 1234567&lt;#setting number_format=&quot;currency&quot;/&gt; &lt;#assign answer=42/&gt; $&#123;answer&#125; &lt;#-- 结果为：42.00 --&gt;$&#123;answer?string&#125; &lt;#-- the same as $&#123;answer&#125; --&gt; $&#123;answer?string.number&#125; &lt;#-- 结果为：42 --&gt;$&#123;answer?string.currency&#125; &lt;#-- 结果为：42.00 --&gt;$&#123;answer?string.percent&#125; &lt;#-- 结果为：4,200% --&gt; 日期型根据默认格式(由#setting指令设置)将表达式结果转换成文本输出。可以使用内建的字符串函数格式化单个插值，示例如下： 12345678910111213141516$&#123;.now?string(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125; &lt;#-- 结果为：2008-04-08 08:08:08 --&gt;$&#123;.now?string(&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;)&#125; &lt;#-- 结果为：2008-04-08 08:08:08 Pacific Daylight Time --&gt;$&#123;.now?string(&quot;EEE, MMM d, &apos;&apos;yy&quot;)&#125; &lt;#-- 结果为：Tue, Apr 8, &apos;03 --&gt;$&#123;.now?string(&quot;EEEE, MMMM dd, yyyy, hh:mm:ss a &apos;(&apos;zzz&apos;)&apos;&quot;)&#125; &lt;#-- 结果为：Tuesday, April 08, 2003, 08:08:08 PM (PDT) --&gt;&lt;#-- 日期格式化其他处理方式 --&gt;&lt;#-- 1.只显示日期，不显示时间：date --&gt;$&#123;.now?date&#125; 或 $&#123;.now?date(&apos;yyyy-MM-dd&apos;)&#125;&lt;#-- 2.只显示时间，不显示日期：time --&gt;$&#123;.now?time&#125; 或 $&#123;.now?time(&apos;hh:mm:ss&apos;)&#125;&lt;#-- 3.时间、日期都显示：datetime --&gt;$&#123;.now?datetime(&apos;yyyy-MM-dd hh:mm:ss&apos;)&#125; 布尔型根据默认格式(由#setting指令设置)将表达式结果转换成文本输出。可以使用内建的字符串函数格式化单个插值，示例如下： 12&lt;#assign foo=true/&gt; $&#123;foo?string(&quot;yes&quot;, &quot;no&quot;)&#125; &lt;#-- 结果为：yes --&gt; 数字格式化插值数字格式化插值可采用#{expr;format}形式来格式化数字,其中format可以是: mX:小数部分最小X位 MX:小数部分最大X位 12345678&lt;#assign x=2.582/&gt; &lt;#assign y=4/&gt; #&#123;x; M2&#125; &lt;#-- 输出2.58 --&gt; #&#123;y; M2&#125; &lt;#-- 输出4 --&gt; #&#123;x; m2&#125; &lt;#-- 输出2.6 --&gt; #&#123;y; m2&#125; &lt;#-- 输出4.0 --&gt; #&#123;x; m1M2&#125; &lt;#-- 输出2.58 --&gt; #&#123;x; m1M2&#125; &lt;#-- 输出4.0 --&gt; 集合集合以方括号包括,各集合元素之间以英文逗号”,”分隔，通过list指令迭代输出。示例如下： 123&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt; $&#123;x&#125; &lt;/#list&gt; 判空处理FreeMarker默认是不允许值为空或者值不存在的，否则一定会报错。所以我们需要一些方法来判断是否为空或者是否存在。 为了处理缺失变量,FreeMarker提供了两个运算符: !:指定缺失变量的默认值 12$&#123;user!&quot;Anonymous&quot;&#125; &lt;#-- 指定默认值，不存在或为空时显示 Anonymous --&gt;$&#123;user!&#125; &lt;#-- user不存在或为空时候，不会报错，也不会输出 --&gt; ??:判断某个变量是否存在 1234&lt;#if name??&gt;$&#123;name&#125;&lt;/#if&gt; &lt;#-- 先判断name，若name为空或不存在则不会执行if内部的，也不会报错 --&gt; 前端常用指令assign用于为该模板页面创建或替换一个顶层变量 if123456&lt;#assign age=23&gt; &lt;#if (age&gt;60)&gt;老年人 &lt;#elseif (age&gt;40)&gt;中年人 &lt;#elseif (age&gt;20)&gt;青年人 &lt;#else&gt; 少年人 &lt;/#if&gt; 注： if条件中使用插值时不需加 $ ,直接使用变量名即可 逻辑表达式用括号括起来主要是因为里面有&gt;符号,由于FreeMarker会将&gt;符号当成标签的结束字符,可能导致程序出错；或者可使用 gt 、lt 等代替比较运算符 listlist指令是一个迭代输出指令,用于迭代输出数据模型中的集合,list指令的语法格式如下: 123&lt;#list sequence as item&gt; ... &lt;/#list&gt; 上面的语法格式中,sequence就是一个集合对象,也可以是一个表达式,但该表达式将返回一个集合对象,而item是一个任意的名字,就是被迭代输出的集合元素.此外,迭代集合对象时,还包含两个特殊的循环变量: item_index:当前变量的索引值 item_has_next:是否存在下一个对象 — 可用于判断是否为集合中最后一个元素 也可以使用&lt;#break&gt;指令跳出迭代 ，例子如下: 1234&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt; $&#123;x_index + 1&#125;.$&#123;x&#125;&lt;#if x_has_next&gt;,&lt;/if&gt; &lt;#if x=&quot;星期四&quot;&gt;&lt;#break&gt;&lt;/#if&gt; &lt;/#list&gt; include用于包含指定页 1&lt;#include filename [options]&gt; 上面的参数表示： filename:该参数指定被包含的模板文件 options:该参数可以省略,指定包含时的选项,包含encoding和parse两个选项,其中encoding指定包含页面时所用的解码集,而parse指定被包含文件是否作为FTL文件来解析,如果省略了parse选项值,则该选项默认是true。 import用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中 1&lt;#import &quot;/lib/common.ftl&quot; as com&gt; 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中 js 获取 freemarker 中的变量1234&lt;#assign code=&quot;123&quot;&gt;&lt;script&gt; var codeList = &quot;$&#123;code&#125;&quot;;//注意使用双引号&lt;/script&gt; 操作字符串注：使用下列方法时以 ？ 形式调用，eg:${‘str’?substring(0)} 方法 作用 substring(start,end) 从一个字符串中截取子串，start必须大于等于0，小于等于end，end必须大于等于0，小于等于字符串长度，如果省略该参数，默认为字符串长度。 cap_first 将字符串中的第一个单词的首字母变为大写。 uncap_first 将字符串中的第一个单词的首字母变为小写。 capitalize 将字符串中的所有单词的首字母变为大写 ends_with 判断某个字符串是否由某个子串结尾，返回布尔值。布尔值必须转换为字符串才能输出。eg:${“string”?ends_with(“ing”)?string} 返回结果为true index_of(substring,start) 在字符串中查找某个子串，返回找到子串的第一个字符的索引，如果没有找到子串，则返回-1。Start参数用于指定从字符串的那个索引处开始搜索，start为数字值。如果start大于字符串长度，则start取值等于字符串长度，如果start小于0， 则start取值为0。 length 返回字符串的长度 lower_case 将字符串转为小写 upper_case 将字符串转为大写 contains 判断字符中是否包含某个子串。返回布尔值。布尔值必须转换为字符串才能输出。eg:${“string”?contains(“ing”)?string} à结果为true number 将字符串转换为数字 replace(str1,str2) 用于将字符串中的一部分从左到右替换为另外的字符串，eg:${“strabg”?replace(“ab”,”in”)} 结果为string split(str) 使用指定的分隔符将一个字符串拆分为一组字符串]]></content>
      <categories>
        <category>模板引擎</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO--搜索引擎优化]]></title>
    <url>%2FSEO-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SEO(Search English Optimization)，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 SEO简介意义为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望百度等搜索引擎能多多我们收录精心制作后的网站，并且在别人访问时网站能排在前面。 分类分为白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO。 前端SEO网站结构布局优化一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬。在网站结构优化方面，应提倡扁平化结构。 控制首页链接数量网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。因此对于中小型企业网站，建议首页链接在100个以内，链接的性质可以包含页面导航、底部导航、锚文字链接等等，注意链接要建立在用户的良好体验和引导用户获取信息的基础之上。 扁平化的目录层次尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。扁平化的目录结构，比如：“植物”–&gt; “水果” –&gt; “苹果”、“桔子”、“香蕉”，通过3级就能找到香蕉了。 导航优化导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，&lt;img&gt;标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。 网站的结构布局 页面头部：logo及主导航，以及用户的信息。 页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。 页面底部：版权信息和友情链接。 特别注意：分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。 控制页面的大小减少http请求，提高网站的加载速度。一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。 网页代码优化 &lt;title&gt;：标题，只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的&lt;title&gt;标题中不要设置相同的内容。 &lt;meta keywords&gt;：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。 &lt;meta description&gt;：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 &lt;body&gt;中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6是用于标题类的，&lt;nav&gt;标签是用来设置页面主导航的等。 &lt;a&gt;：页内链接，要加“title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上rel=”nofollow”属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。 &lt;h1&gt;：“蜘蛛” 认为它最重要，若不喜欢&lt;h1&gt;的默认样式可以通过CSS设置。尽量做到正文标题用&lt;h1&gt;标签，副标题用&lt;h2&gt;标签, 而其它地方不应该随便乱用 h 标题标签。 &lt;br&gt;标签：只用于文本内容的换行 表格应该使用&lt;caption&gt;表格标题标签 &lt;img&gt;：应使用 “alt” 属性加以说明 &lt;strong&gt;、&lt;em&gt;: 需要强调时使用。&lt;strong&gt;标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，&lt;em&gt;标签强调效果仅次于标签。&lt;b&gt;、&lt;i&gt;标签: 只是用于显示效果时使用，在SEO中不会起任何效果。 文本缩进不要使用特殊符号&nbsp; 应当使用CSS进行设置。 版权符号不要使用特殊符号 &copy; 可以直接使用输入法或复制此处符号：©。 巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。 重要内容不要用JS输出，因为“蜘蛛”不认识 尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容 谨慎使用display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。 js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。 注意： 本文摘录自CSDN博主「徐小七七」的原创文章原文链接：https://blog.csdn.net/xustart7720/article/details/79960591]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用js方法小结]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8js%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在写网页的过程中经常会用到一些特定功能的函数，本文记录一些常用的js方法，以便随时查用。使用时请根据实际情况对函数进行修改。 获取地址栏参数12345678910function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配 var context = ""; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == "" || context == "undefined" ? "" : context; &#125; 验证手机号12345678function checkTel(str)&#123; var myreg=/^[1][0-9]&#123;10&#125;$/; if(!myreg.test(str))&#123; return false &#125;else&#123; return true &#125;&#125; 移动端rem布局12345678910111213(function(doc, win) &#123; var de = doc.documentElement, re = 'orientationchange' in window ? 'orientationchange': 'resize', recalc = function() &#123; var cw = de.clientWidth; if (!cw) return; de.style.fontSize = cw &gt;= 750 ? '100px': 100 * (cw / 750) + 'px'; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(re, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 唤起app1234567891011121314151617181920212223242526272829303132333435363738//创建baseSchemevar baseSchemeAdr = "Andeoid唤起协议";var baseSchemeIOS = "IOS唤起协议";var downLoadUrl = "下载APP的url";var u = navigator.userAgent;var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端//打开APPvar openApp=function()&#123; if(isiOS)&#123; //判断是否是ios,具体的判断函数自行百度 window.location.href = baseSchemeIOS; var loadDateTime = Date.now(); setTimeout(function () &#123; var timeOutDateTime = Date.now(); if (timeOutDateTime - loadDateTime &lt; 4000) &#123; window.location.href = downLoadUrl; &#125; &#125;, 3000); &#125;else if(isAndroid)&#123; var loadDateTime = Date.now(); //判断是否是android document.getElementById('openapp-btn').href = baseSchemeAdr; document.getElementById('openapp-btn').click(); setTimeout(function () &#123; var timeOutDateTime = Date.now(); if (timeOutDateTime - loadDateTime &lt; 2000) &#123; window.location.href = downLoadUrl; &#125; &#125;, 1500); &#125;else&#123; //主要是给winphone的用户准备的 window.location.href = baseSchemeIOS; setTimeout(function () &#123; window.location.href = downLoadUrl; &#125;, 500); &#125;&#125; cookie的相关操作设置cookie12345678910111213/*c_name : 传入的键（str） value : 传入的值（str） expiredays : 有效期 / 天为单位(number)*/function setCookie (c_name,value,expiredays) &#123; var exdate=new Date() exdate.setDate(exdate.getDate()+expiredays) document.cookie=c_name+ "=" +escape(value)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString());&#125;;var token = 'asds4145451211122-41';setCookie('token',token,1) 获取cookie123456789101112131415161718//c_name : 获取的cookie键（str）function getCookie (c_name) &#123; if (document.cookie.length&gt;0) &#123; var c_start=document.cookie.indexOf(c_name + "=") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 var c_end=document.cookie.indexOf(";",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return ""&#125;;var token = getCookie('token');alert(token) 删除Cookie12345678910//name : 要删除的cookie键(str)function delCookie (name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString();&#125;delCookie('token') 时间格式化1234567891011121314151617181920Date.prototype.Format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;;var temp = 1570684251000;console.log(new Date(temp).Format("yyyy-MM-dd hh:mm:ss"))// 输出结果为：2019-10-10 13:10:51console.log(new Date(temp).Format("yyyy/MM/dd hh:mm:ss"))// 输出结果为：2019/10/10 13:10:51 倒计时已知开始时间和结束时间的倒计时12345678910111213141516171819202122232425262728293031/*用于计算未来某天距离当前的倒计时id--倒计时的元素idendDateStr-- 截止时间*/function timeDown(startDate,endDateStr) &#123; //结束时间 var endDate = new Date(endDateStr); //当前时间 var startDate = new Date(startDate); //相差的总秒数 var totalSeconds = parseInt((endDate - startDate) / 1000); //天数 var days = Math.floor(totalSeconds / (60 * 60 * 24)); //取模（余数） var modulo = totalSeconds % (60 * 60 * 24); //小时数 var hours = Math.floor(modulo / (60 * 60)); modulo = modulo % (60 * 60); //分钟 var minutes = Math.floor(modulo / 60); //秒 var seconds = modulo % 60; // 展示到页面中：此处不做处理，根据实际情况进行修改 //延迟一秒执行自己 setTimeout(function () &#123; timeDown(startDate, endDateStr); &#125;, 1000)&#125; 获取短信验证码类（指定时间）的倒计时123456789101112131415// id--获取验证码的按钮function codeTime(id)&#123; $(id).attr('disabled','disabled').css('opacity',.6); var time = 60;// 以60s为例 $(id).html(time + 's后重新发送'); var t = setInterval(function()&#123; time --; if(time == 0)&#123; clearInterval(t); $(id).removeAttr('disabled').css('opacity',1).html('发送验证码'); &#125;else&#123; $(id).html(time + 's后重新发送'); &#125; &#125;,1000)&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app内嵌h5页面问题小结]]></title>
    <url>%2Fapp%E5%86%85%E5%B5%8Ch5%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原生app能内嵌H5，是因为有了webview这个app内嵌浏览器视图，使得我们可以开发html然后加载到app中（原理几乎跟pc端请求、加载、渲染是一样的），一般的当我们将h5开发好后就可以有两种方式请求到原生app中，一个是将html代码放到服务器上，一个是放在当前app项目目录中本地请求（一般用于调试）。 app与内嵌h5页面实现交互通过函数的调用实现。app调用js方法时前端提供方法名及参数即可，js调用app的方法时需区分设备是ios还是安卓，然后分别调用。 判断是ios还是安卓123456var ua = navigator.userAgent.toLowerCase();if(/iphone|ipad|ipod/.test(ua))&#123; console.log('IOS')&#125;else&#123; console.log('Android')&#125; 调用app原生方法示例具体如何使用应以实际ios和安卓人员提供的方法为准，以下示例仅供参考。 12345678910111213141516function jumpCustom(id)&#123; if(/iphone|ipad|ipod/.test(ua))&#123; if(id)&#123; window.webkit.messageHandlers.openCustomView.postMessage([id]); &#125;else&#123; window.webkit.messageHandlers.openCustomView.postMessage(null); &#125; &#125;else&#123; if(id)&#123; window.android.openCustomView(id); &#125;else&#123; window.android.openCustomView(); &#125; &#125;&#125; ios内嵌h5页面遇到的问题时间转为毫秒时不支持“2018-08-30”的格式1234// 报错，NANnew Date('2018-08-30').getTime()// 需转换成 '/'new Date('2018-08-30'.replace(/-/g,'/')).getTime() ios在内嵌网页的url后带中文参数传参时如果有中文参数会导致接收到的参数被编码或者页面空白，此时需处理所传参数。在h5页面中做如下处理： 1234567891011121314151617//得到页面的urlvar initUrl = window.location.href;//对含有中文的url进行解码,注意是两次解码var URL_decode = decodeURI(decodeURI(initUrl));// 获取地址栏参数function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配 var context = ""; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == "" || context == "undefined" ? "" : context; &#125;// url传参时获取初始值var initTit = decodeURI(GetQueryString('title'));]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mip改造小记]]></title>
    <url>%2Fmip%E6%94%B9%E9%80%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MIP（Mobile Instant Pages - 移动网页加速器），是一套应用于移动网页的开放性技术标准。通过提供 MIP-HTML 规范、MIP-JS 运行环境以及 MIP-Cache 页面缓存系统，实现移动网页加速。 mip简介MIP 主要由三部分组成： MIP-HTML：基于 HTML 中的基础标签制定了全新的规范，通过对一部分基础标签的使用限制或功能扩展，使 HTML 能够展现更加丰富的内容。 MIP-JS：可以保证 MIP-HTML 页面的快速渲染。 MIP-Cache：用于实现 MIP 页面的高速缓存，从而进一步提高页面性能。 mip页面改造mip的页面改造需要符合mip规范，大致有以下几点： css： mip页面中不允许使用行内样式 如果需要补充样式，仅允许在 &lt;head&gt;标签中使用 &lt;style mip-custom&gt;&lt;/style&gt; ，且只可出现一次 js: mip页面中不允许使用自定义的js，也不允许引入除了官方组件（包括站长组件）之外的js 所有页面 必须 在 &lt;body&gt; 的 最后 编写或引用 mip 相关的 js 如有需要，可使用 mip-script 标签进行少量js的书写 html: 所有页面 必须 包含 &lt;html&gt;, &lt;head&gt;, &lt;body&gt; a 标签的href属性为必填，锚点定位仍可用，但不允许使用 ‘javascript:;’ 之类，不允许使用 target 属性，具体可参看官网要求 img 标签需替换为 mip-img ,同时应设定好图片的宽高属性（width 、height） form 等表单元素的使用需参看 mip 官网说明 图片轮播、tab切换等功能，均可通过 mip 提供的官方组件实现本文仅列常见几点以供参考，具体规范请详读官网。 mip开发站长组件fork mip的官方站长组件仓库 浏览器进入 GitHub 中 MIP 官方组件代码仓库，点击右上角的 fork 按钮，fork 完成后，在你 GitHub 主页下的 Repositories 下会多出一个 mip2-extensions-platform 仓库 新建文件夹 mip-project，进入该文件夹右键 -&gt; Git Bash Here -&gt; git clone https://项目地址tips: git窗口中复制快捷键:ctrl + insert 粘贴：shift + insert 创建开发项目 mip-project 文件夹下进入 sites ，路径下输入cmd打开命令窗口，下载 mip2-cli 1npm install mip2-cli -g 创建项目 12mip2 init 项目名称（以cngold.org为例）cd cngold.org 新增组件 1mip2 add mip-jt-stock 调试预览 1mip2 dev 检验 1mip2 validate -c ./components 检查js规范：根据提示进行规范修改 1234// 安装eslintnpm install -g eslint // 进入索要检测的js文件所在目录eslint mip-jt-stock.js 提交 进入 mip-project 目录，添加仓库 12345678// 对比本地仓库与线上仓库的改动git status// 查看自己当前git仓库的configure,origin代表自己的仓库git remote -v// 添加新的远程仓库git remote add mip2-upstream（仓库名，可自定义） 原项目地址（即mip官方站长组件库对应地址）// 再次查看当前git仓库的configure，若出现mip2-upstream（或自定义的仓库名），则为添加成功git remote -v 提交代码 123456// . 代表添加所有改动文件，也可自行指定所要提交的文件git add .// 注释说明git commit -m &apos;注释内容&apos;// 提交到自己的仓库git push origin 发起 Pull Request，申请合并到官方站长组件库 打开自己的 github ，找到fork的项目 进入项目， new pull request -&gt; create pull create，添加说明内容并提交审核（具体提交规范参看官网） Pull request 提交后，会自动触发持续集成的任务，如代码规范检查、部署预览等，在 Conversation 选项卡可以看到实时状态。如果有不通过的，需要再次修改提交，确保所有检查项都成功通过，官方才能审核合入 并不是每次提交都需要 pull request ，在同一分支下 push 代码时，所有的 commits 都会被自动追加到 pull request 后面 在 marge 到原项目仓库地址后，即为该条 pull request 关闭，再次提交时需重新发起。 mip-cacheMIP-Cache 给所有符合规范的 MIP 页面提供 CDN 缓存服务，能够主动的提高页面加载速度，为使用 MIP-Cache 服务的页面上的图片、CSS 文件等资源提供缓存服务，这样能做到所有 HTTP 请求来自于同源，能够加速加载速度，并且缓存后的页面都是 HTTPS 的，安全性更高。其他描述请参看官网。 如何快速更新 mip-cache 登录百度账号之后，进入 https://ziyuan.baidu.com/mip/index ，选择对应站点 获取Authkey http站点接口调用地址：http://c.mipcdn.com/update-ping/c/urlhttps站点接口调用地址：http://c.mipcdn.com/update-ping/c/s/url注：https://mip.xxx.com/ 和 https://mip.xxx.com在MIPCache中属于不同的URL链接，请务必保证mip数据中提交的URL链接和百度收录链接保持一致。 运行清除缓存的代码，以php为例，本地开启 WAMP ，进入 www 目录，将示例代码放入页面，进入 localhost 访问页面，是否清除缓存成功请参看百度（status 为0） 1234567891011$api = 'http://c.mipcdn.com/update-ping/c/';$postData = 'key=348d7e884c581428395cec452bc32032';$url = $api.urlencode('m.120ask.com/askg/bd_detail/39372771');$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);$result = curl_exec($ch);curl_close($ch);echo $result;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>mip</tag>
      </tags>
  </entry>
</search>
