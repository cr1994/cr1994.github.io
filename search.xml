<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于console]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Econsole%2F</url>
    <content type="text"><![CDATA[Console 对象用于 JavaScript 调试。JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 Console 对象常见的两个用途： 1. 显示网页代码运行时的错误信息。 2. 提供了一个命令行接口，用来与网页代码互动。 console 对象有很多方法，仅列出以下常见的几种： console.log() 输出信息 console.info() 与 console.log() 作用一样 console.error() 输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。 console.warn() 输出警告信息 有时候我们会看到 console.log(‘%s’,arr);这种写法相对来说并不常见。 上面所列的几种方法都支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o） 占位符 作用 %s 字符串 %d 或 %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串。 12345678910111213141516console.log("%d年%d月%d日",2011,3,26);// 格式成可展开的的DOM，像在开发者工具Element面板那样可展开 console.log('%o',document.body.firstElementChild); // 像JS对象那样访问DOM元素，可查看DOM元素的属性 // 等同于console.dir(document.body.firstElementChild) console.log('%O',document.body.firstElementChild);// 输出带样式的文字console.log("%c红色20px文字","color: red; font-size: 20px"); /* 输出图片，由于 console 不能定义 img，因此用背景图片代替。此外，console 不支持 width 和 height，利用空格和 font-size 代替；还可以使用 padding 和 line-height 代替宽高。 */console.log("%c","background:url(https://static.runoob.com/images/runoob-logo.png) no-repeat;padding:50px 300px;line-height:120px"); 注：使用 %c 占位符时，对应的后面的参数必须是 CSS 语句，用来对输出内容进行 CSS 渲染。常见的输出方式有两种：文字样式、图片输出。 其他常见方法： console.dir() 查看对象的信息 console.dirxml() 用来显示网页的某个节点（node）所包含的html/xml代码。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--Map和Set]]></title>
    <url>%2FES6-Map%E5%92%8CSet%2F</url>
    <content type="text"><![CDATA[ES6中新增的数据结构：Map和Set。 MapMap数据结构是为了解决对象无法使用非字符串作为键而提出的数据结构，本质上讲，Map是一个二维数组，其中数组元素是只含有两个元素的数组，这两个元素按顺序分别为键和值。如var m = new Map([[x, 1], [y, 2]]);实际上，最常用的形式是把对象作为键，对象相关的信息作为值来存储在Map中。 初始化Map1var m = new Map(); 方法set(key,value)设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则进行覆盖更新，否则新生成。 12345678910111213// 1.对象作为键var map_1 = new Map();var obj = &#123;p1:'v1'&#125;;map_1.set(obj,'hello');console.log(map_1.get(obj));// 结果为 hello// 2.数组作为参数var map_2 = new Map([ ['name','cr'], ['age',18]]);console.log(map_2.get('name'));// 结果为 crconsole.log(map_2.get('age'));// 结果为 18 size返回Map结构的成员总数 1console.log('%s',map_2.size);// 结果为 2 get(key)读取key对应的键值，如果找不到key,则返回undefined 12console.log(map_2.get('name'));// 结果为 crconsole.log(map_2.get('sex'));// 结果为 undefined has(key)某个键是否存在Map数据结构中，返回布尔值 12console.log(map_2.has('name'));// 结果为 trueconsole.log(map_2.has('sex'));// 结果为 false delete(key)删除某个键，返回布尔值；如果删除的是不存在的key，返回false 12map_2.delete('sex') // falsemap_2.delete('age') //true clear()清除所有成员，没有返回值 12map_2.clear();console.log(map_2);// 结果为：Map(0) &#123;&#125; 遍历keys() — 遍历键名123456for (v of map_2.keys())&#123; console.log(v)&#125;// 输出结果为// name// age values() — 遍历值123456for (v of map_2.values())&#123; console.log(v)&#125;// 输出结果为// cr// 18 entries() — 遍历键值对123456for (v of map_2.entries())&#123; console.log(v)&#125;// 输出结果为// ['name','cr']// ['age',18] forEach(value,key,map) — 遍历Map的所有成员123456map_2.forEach(function(value, key, map) &#123; console.log("Key: %s, Value: %s", key, value);&#125;)// 输出结果为 // Key: name, Value: cr// Key: age, Value: 18 与js其他数据类型的转化Map 转 数组使用扩展运算符（…）可将map内的元素都展开的数组；或者使用Array.from() 注: Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例 123456789let map_3 = new Map();map_3.set('k1', 1);map_3.set('k2', 2);map_3.set('k3', 3);console.log([...map_3]);console.log(Array.from(map_3));// 输出结果均为： [['k1',1],['k2',2],['k3',3]] 数组 转 Map123456const map_4 = new Map([ ['name', 'Aissen'], ['age', 12]])console.log(map_4);// 结果为 &#123;"name" =&gt; "Aissen", "age" =&gt; 12&#125; Map 转 对象写一个转换函数，遍历map的所有元素，将元素的键和值作为对象属性名和值写入Object中。 1234567891011121314function mapToObj(map) &#123; let obj = Object.create(null); for (let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125;const map_5 = new Map() .set('k1', 1) .set(&#123;pa:1&#125;, 2);console.log(mapToObj(map_5))// 结果为：&#123; k1: 1, '[object Object]': 2 &#125; 对象 转 Map写一个转换函数，遍历Object，将属性名和值作为键值对写入Map 12345678910function objToMap(obj) &#123; let map = new Map(); for (let k of Object.keys(obj)) &#123; map.set(k, obj[k]); &#125; return map;&#125;console.log(objToMap(&#123;yes: true, no: false&#125;))// 结果为：&#123; 'yes' =&gt; true, 'no' =&gt; false &#125; Set类似于数组，但是成员的值都是唯一的，没有重复值。可用来去重。但是在 set 中，数字3和字符串’3’是不同的元素。注：Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。在 Set 内部，两个NaN是相等。另外，两个对象总是不相等的。 初始化Set1let set_1 = new Set(); 方法add(value)添加某值，返回Set结构本身 123456789let set_2 = new Set();set_2.add(1);set_2.add('1');set_2.add(2);set_2.add(2);console.log(set_2);// 结果为：&#123;1,'1',2&#125; size返回Set结构的成员总数 1console.log('%s',set_2.size);// 结果为 3 delete(value)删除某值，返回布尔值。如果删除的是不存在的key，返回false 12set_2.delete('1');// trueset_2.delete('222');// false has(value)检测Set的成员是否有这个值，返回布尔值 12set_2.has(1);// trueset_2.has('111');// false clear()清除所有成员，不返回值 12set_2.clear();console.log('%s',set_2.size);// 结果为 0 遍历与Map的遍历基本一致，此处不再赘述。 与 Map 的转化Map 转 Set12345678910111213function mapToSet(map) &#123; let set = new Set() for (let [k,v] of map) &#123; set.add([k, v]) &#125; return set;&#125;const map_6 = new Map() .set('k1', 1) .set(&#123;pa:1&#125;, 2);console.log(mapToSet(map_6))// 结果为：&#123;['k1',1],[&#123;pa:1&#125;,2]&#125; Set 转 Map1234567const set_3 = new Set([ ['foo', 1], ['bar', 2]]);const map_7 = new Map(set)console.log(map_7)// 结果为：&#123; 'foo' =&gt; 1, 'bar' =&gt; 2 &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常见兼容问题]]></title>
    <url>%2Fjs%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文总结一些常见的js在浏览器中的兼容问题以供参考。以下内容是在网上搜集资料整理而成，尊重原作者版权，由于资料来源不一，未写原作者及出处，敬请谅解。 获取浏览器宽高12345678910111213141516// 网页可见区域宽var winW = document.body.clientWidth || document.docuemntElement.clientWidth;// 网页可见区域高var winH = document.body.clientHeight || document.docuemntElement.clientHeight;// 以上为不包括边框的宽高，如果是offsetWidth或者offsetHeight的话包括边框// 整个网页的宽var winWW = document.body.scrollWidth || document.docuemntElement.scrollWidth;// 整个网页的高var winHH = document.body.scrollHeight || document.docuemntElement.scrollHeight;// 滚动条// 网页被卷去的高var scrollHeight = document.body.scrollTop || document.docuemntElement.scrollTop;// 网页左卷的距离var scrollLeft = document.body.scrollLeft || document.docuemntElement.scrollLeft; event事件问题123456789101112131415161718192021222324252627282930313233343536373839404142document.onclick = function(ev)&#123;//兼容写法； var e = ev || window.event; var mouseX = e.clientX;//鼠标X轴的坐标 var mouseY = e.clientY;//鼠标Y轴的坐标&#125;// event事件中的targetdocument.onmouseover = function(e)&#123; var e = e || window.event; var Target = e.target || e.srcElement;//获取target的兼容写法，后面的为IE var from = e.relatedTarget || e.formElement;//鼠标来的地方，同样后面的为IE var to = e.relatedTarget || e.toElement;//鼠标去的地方&#125;// 阻止冒泡document.onclick = function(e)&#123; var e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation();//W3C标准 &#125;else&#123; e.cancelBubble = true;//IE &#125;&#125;// 阻止默认事件document.onclick = function(e)&#123; var e = e || window.event; if (e.preventDefault) &#123; e.preventDefault();//W3C标准 &#125;else&#123; e.returnValue = 'false';//IE &#125;&#125;// 获取键盘按下的键值document.onkeydown = function(e)&#123; var theEvent = e || window.event; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; console.log('按下的是回车键'); &#125; &#125; 获取DOM节点123456789101112131415161718192021222324252627282930313233//DOM节点相关，主要兼容IE 6 7 8//获取下一个兄弟节点function nextnode(obj)&#123; if (obj.nextElementSibling) &#123; return obj.nextElementSibling; &#125; else&#123; return obj.nextSibling; &#125;;&#125;//获取上一个兄弟节点function prenode(obj)&#123; if (obj.previousElementSibling) &#123; return obj.previousElementSibling; &#125; else&#123; return obj.previousSibling; &#125;;&#125;//获取第一个子节点function firstnode(obj)&#123; if (obj.firstElementChild) &#123; return obj.firstElementChild;//非IE678支持 &#125; else&#123; return obj.firstChild;//IE678支持 &#125;;&#125;//获取最后一个子节点function lastnode(obj)&#123; if (obj.lastElementChild) &#123; return obj.lastElementChild;//非IE678支持 &#125; else&#123; return obj.lastChild;//IE678支持 &#125;;&#125; 通过类名获取元素1234567891011121314151617181920212223242526272829//通过类名获取元素document.getElementsByClassName('');//IE 6 7 8不支持；//这里可以定义一个函数来解决兼容问题// 1.全局获取，oClass为你想要查找的类名，没有“.”function byClass1(oClass)&#123; var tags=document.all?document.all:document.getElementsByTagName('*'); var arr=[]; for (var i = 0; i &lt; tags.length; i++) &#123; var reg=new RegExp('\\b'+oClass+'\\b','g'); if (reg.test(tags[i].className)) &#123; arr.push(tags[i]); &#125;; &#125;; return arr;//注意返回的也是数组，包含你传入的class所有元素；&#125;// 2.局部获取类名，parentID为你传入的父级IDfunction byClass2(parentID,oClass)&#123; var parent=document.getElementById(parentID); var tags=parent.all?parent.all:parent.getElementsByTagName('*'); var arr=[]; for (var i = 0; i &lt; tags.length; i++) &#123; var reg=new RegExp('\\b'+oClass+'\\b','g'); if (reg.test(tags[i].className)) &#123; arr.push(tags[i]); &#125;; &#125;; return arr;//注意返回的也是数组，包含你传入的class所有元素；&#125; 获取元素的非行间样式值：12345678//获取元素的非行间样式值function getStyle(object,oCss) &#123; if (object.currentStyle) &#123; return object.currentStyle[oCss];//IE &#125;else&#123; return getComputedStyle(object,null)[oCss];//除了IE &#125;&#125; 事件监听12345678910111213141516// 设置监听事件function addEvent(obj,type,fn)&#123;//添加事件监听，三个参数分别为 对象、事件类型、事件处理函数，默认为false if (obj.addEventListener) &#123; obj.addEventListener(type,fn,false);//非IE &#125; else&#123; obj.attachEvent('on' + type,fn);//IE,这里已经加上on，传参的时候注意不要重复加了 &#125;;&#125;// 删除事件监听function removeEvent(obj,type,fn)&#123; if (obj.removeEventListener) &#123; obj.removeEventListener(type,fn,false);//非IE &#125; else&#123; obj.detachEvent('on'+type,fn);//IE，这里已经加上on，传参的时候注意不要重复加了 &#125;;&#125; 鼠标的滚轮事件1234567891011121314151617//火狐中的滚轮事件document.addEventListener("DOMMouseScroll",function(event)&#123; if(event.detail == -3)&#123; console.log('前滚') &#125;else if(event.detail == 3)&#123; console.log('后滚') &#125;&#125;,false)//非火狐中的滚轮事件document.onmousewheel = function(event)&#123; if(event.detail == 120)&#123; console.log('前滚') &#125;else if(event.detail == -120)&#123; console.log('后滚') &#125;&#125; console在IE下报错报错原因：在IE下没打开IE浏览器控制台的情况下是没有console对象的。 123456// 使用时需自行定义window.console = window.console || (function () &#123; var c =&#123;&#125;; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile= c.clear = c.exception = c.trace = c.assert = function()&#123;&#125;; return c;&#125;)(); ajax请求不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。eg：IE 浏览器使用 ActiveXObject 来创建，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象来创建。 12345678910111213141516171819202122//浏览器支持代码function ajaxFunction() &#123; var ajaxRequest; // 声明一个ajaxRequest变量，用来保存XMLHttpRequest 对象 try &#123; // 兼容：Opera 8.0+, Firefox, Safari ajaxRequest = new XMLHttpRequest(); //创建XMLHttpRequest 对象 &#125; catch (e) &#123; // 兼容：Internet Explorer 浏览器 try &#123; ajaxRequest = new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; try &#123; ajaxRequest = new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; // 出了问题时 alert("您的浏览器不支持Ajax！"); return false; &#125; &#125; &#125;&#125; IE6/7 不支持 JSON.parse和JSON.stringify123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if(!window.JSON)&#123; window.JSON = &#123; parse: function(sJson)&#123; return eval("(" + sJSON + ")"); &#125;, stringify: function(obj)&#123; var result = ""; for(var key in obj)&#123; if(typeof obj[key] == "string")&#123; // 如果属性值是String类型，属性值需要加上双引号 result += "\"" + key + "\":\"" + obj[key] + "\","; &#125;else if(obj[key] instanceof RegExp)&#123; // 如果属性是正则表达式，属性值只保留一对空大括号&#123;&#125; result += "\"" + key + "\":&#123;&#125;,"; &#125;else if(typeof obj[key] == "undefined" || obj[key] instanceof Function)&#123; // 如果属性值是undefined, 该属性被忽略。忽略方法。 &#125;else if(obj[key] instanceof Array)&#123; // 如果属性值是数组 result += "\"" + key + "\":["; var arr = obj[key]; for(var item in arr)&#123; if(typeof arr[item] == "string")&#123; // 如果数组项是String类型，需要加上双引号 result += "\"" + arr[item] + "\","; &#125;else if(arr[item] instanceof RegExp)&#123; // 如果属数组项是正则表达式，只保留一对空大括号&#123;&#125; result += "&#123;&#125;,"; &#125;else if(typeof arr[item] == "undefined" || arr[item] instanceof Function)&#123; // 如果数组项是undefined, 则显示null。如果是函数，则显示null?。 result += null +","; &#125;else if(arr[item] instanceof Object)&#123; //如果数组项是对象(非正则，非函数，非null)，调用本函数处理 result += this.stringify(arr[item]) +","; &#125;else&#123; result += arr[item] + ","; &#125; &#125; result = result.slice(0,-1)+"]," &#125;else if(obj[key] instanceof Object)&#123; // 如果属性值是对象(非null，非函数，非正则)，调用本函数处理 result += "\"" + key + "\":" + this.stringify(obj[key]) + ","; &#125;else&#123; result += "\"" + key + "\":" + obj[key] + ","; &#125; &#125; // 去除最后一个逗号,两边加&#123;&#125; return "&#123;" + result.slice(0,-1) + "&#125;"; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker初接触]]></title>
    <url>%2Ffreemarker%E5%88%9D%E6%8E%A5%E8%A7%A6%2F</url>
    <content type="text"><![CDATA[FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。模板编写为FreeMarker Template Language (FTL)。本文仅从个人工作中遇到的问题出发加以整理，不全之处敬请谅解。 FreeMarker模板文件主要由如下4个部分组成: 文本:直接输出的部分 注释: &lt;#– … –&gt; 格式部分,不会输出 插值:即 ${…} 或 #{…} 格式的部分,将使用数据模型中的部分替代输出 FTL指令:FreeMarker指定,和HTML标记类似,名字前加 # 予以区分,不会输出 定义变量1&lt;#assign name = &apos;cr&apos;/&gt; 插值的使用通用插值 字符串型 123&lt;div class="name"&gt; 姓名：$&#123;name&#125;&lt;/div&gt; 数字型 1234567&lt;#setting number_format=&quot;currency&quot;/&gt; &lt;#assign answer=42/&gt; $&#123;answer&#125; &lt;#-- 结果为：42.00 --&gt;$&#123;answer?string&#125; &lt;#-- the same as $&#123;answer&#125; --&gt; $&#123;answer?string.number&#125; &lt;#-- 结果为：42 --&gt;$&#123;answer?string.currency&#125; &lt;#-- 结果为：42.00 --&gt;$&#123;answer?string.percent&#125; &lt;#-- 结果为：4,200% --&gt; 日期型根据默认格式(由#setting指令设置)将表达式结果转换成文本输出。可以使用内建的字符串函数格式化单个插值，示例如下： 12345678910111213141516$&#123;.now?string(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125; &lt;#-- 结果为：2008-04-08 08:08:08 --&gt;$&#123;.now?string(&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;)&#125; &lt;#-- 结果为：2008-04-08 08:08:08 Pacific Daylight Time --&gt;$&#123;.now?string(&quot;EEE, MMM d, &apos;&apos;yy&quot;)&#125; &lt;#-- 结果为：Tue, Apr 8, &apos;03 --&gt;$&#123;.now?string(&quot;EEEE, MMMM dd, yyyy, hh:mm:ss a &apos;(&apos;zzz&apos;)&apos;&quot;)&#125; &lt;#-- 结果为：Tuesday, April 08, 2003, 08:08:08 PM (PDT) --&gt;&lt;#-- 日期格式化其他处理方式 --&gt;&lt;#-- 1.只显示日期，不显示时间：date --&gt;$&#123;.now?date&#125; 或 $&#123;.now?date(&apos;yyyy-MM-dd&apos;)&#125;&lt;#-- 2.只显示时间，不显示日期：time --&gt;$&#123;.now?time&#125; 或 $&#123;.now?time(&apos;hh:mm:ss&apos;)&#125;&lt;#-- 3.时间、日期都显示：datetime --&gt;$&#123;.now?datetime(&apos;yyyy-MM-dd hh:mm:ss&apos;)&#125; 布尔型根据默认格式(由#setting指令设置)将表达式结果转换成文本输出。可以使用内建的字符串函数格式化单个插值，示例如下： 12&lt;#assign foo=true/&gt; $&#123;foo?string(&quot;yes&quot;, &quot;no&quot;)&#125; &lt;#-- 结果为：yes --&gt; 数字格式化插值数字格式化插值可采用#{expr;format}形式来格式化数字,其中format可以是: mX:小数部分最小X位 MX:小数部分最大X位 12345678&lt;#assign x=2.582/&gt; &lt;#assign y=4/&gt; #&#123;x; M2&#125; &lt;#-- 输出2.58 --&gt; #&#123;y; M2&#125; &lt;#-- 输出4 --&gt; #&#123;x; m2&#125; &lt;#-- 输出2.6 --&gt; #&#123;y; m2&#125; &lt;#-- 输出4.0 --&gt; #&#123;x; m1M2&#125; &lt;#-- 输出2.58 --&gt; #&#123;x; m1M2&#125; &lt;#-- 输出4.0 --&gt; 集合集合以方括号包括,各集合元素之间以英文逗号”,”分隔，通过list指令迭代输出。示例如下： 123&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt; $&#123;x&#125; &lt;/#list&gt; 判空处理FreeMarker默认是不允许值为空或者值不存在的，否则一定会报错。所以我们需要一些方法来判断是否为空或者是否存在。 为了处理缺失变量,FreeMarker提供了两个运算符: !:指定缺失变量的默认值 12$&#123;user!&quot;Anonymous&quot;&#125; &lt;#-- 指定默认值，不存在或为空时显示 Anonymous --&gt;$&#123;user!&#125; &lt;#-- user不存在或为空时候，不会报错，也不会输出 --&gt; ??:判断某个变量是否存在 1234&lt;#if name??&gt;$&#123;name&#125;&lt;/#if&gt; &lt;#-- 先判断name，若name为空或不存在则不会执行if内部的，也不会报错 --&gt; 前端常用指令assign用于为该模板页面创建或替换一个顶层变量 if123456&lt;#assign age=23&gt; &lt;#if (age&gt;60)&gt;老年人 &lt;#elseif (age&gt;40)&gt;中年人 &lt;#elseif (age&gt;20)&gt;青年人 &lt;#else&gt; 少年人 &lt;/#if&gt; 注： if条件中使用插值时不需加 $ ,直接使用变量名即可 逻辑表达式用括号括起来主要是因为里面有&gt;符号,由于FreeMarker会将&gt;符号当成标签的结束字符,可能导致程序出错；或者可使用 gt 、lt 等代替比较运算符 listlist指令是一个迭代输出指令,用于迭代输出数据模型中的集合,list指令的语法格式如下: 123&lt;#list sequence as item&gt; ... &lt;/#list&gt; 上面的语法格式中,sequence就是一个集合对象,也可以是一个表达式,但该表达式将返回一个集合对象,而item是一个任意的名字,就是被迭代输出的集合元素.此外,迭代集合对象时,还包含两个特殊的循环变量: item_index:当前变量的索引值 item_has_next:是否存在下一个对象 — 可用于判断是否为集合中最后一个元素 也可以使用&lt;#break&gt;指令跳出迭代 ，例子如下: 1234&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt; $&#123;x_index + 1&#125;.$&#123;x&#125;&lt;#if x_has_next&gt;,&lt;/if&gt; &lt;#if x=&quot;星期四&quot;&gt;&lt;#break&gt;&lt;/#if&gt; &lt;/#list&gt; include用于包含指定页 1&lt;#include filename [options]&gt; 上面的参数表示： filename:该参数指定被包含的模板文件 options:该参数可以省略,指定包含时的选项,包含encoding和parse两个选项,其中encoding指定包含页面时所用的解码集,而parse指定被包含文件是否作为FTL文件来解析,如果省略了parse选项值,则该选项默认是true。 import用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中 1&lt;#import &quot;/lib/common.ftl&quot; as com&gt; 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中 js 获取 freemarker 中的变量1234&lt;#assign code=&quot;123&quot;&gt;&lt;script&gt; var codeList = &quot;$&#123;code&#125;&quot;;//注意使用双引号&lt;/script&gt; 操作字符串注：使用下列方法时以 ？ 形式调用，eg:${‘str’?substring(0)} 方法 作用 substring(start,end) 从一个字符串中截取子串，start必须大于等于0，小于等于end，end必须大于等于0，小于等于字符串长度，如果省略该参数，默认为字符串长度。 cap_first 将字符串中的第一个单词的首字母变为大写。 uncap_first 将字符串中的第一个单词的首字母变为小写。 capitalize 将字符串中的所有单词的首字母变为大写 ends_with 判断某个字符串是否由某个子串结尾，返回布尔值。布尔值必须转换为字符串才能输出。eg:${“string”?ends_with(“ing”)?string} 返回结果为true index_of(substring,start) 在字符串中查找某个子串，返回找到子串的第一个字符的索引，如果没有找到子串，则返回-1。Start参数用于指定从字符串的那个索引处开始搜索，start为数字值。如果start大于字符串长度，则start取值等于字符串长度，如果start小于0， 则start取值为0。 length 返回字符串的长度 lower_case 将字符串转为小写 upper_case 将字符串转为大写 contains 判断字符中是否包含某个子串。返回布尔值。布尔值必须转换为字符串才能输出。eg:${“string”?contains(“ing”)?string} à结果为true number 将字符串转换为数字 replace(str1,str2) 用于将字符串中的一部分从左到右替换为另外的字符串，eg:${“strabg”?replace(“ab”,”in”)} 结果为string split(str) 使用指定的分隔符将一个字符串拆分为一组字符串]]></content>
      <categories>
        <category>模板引擎</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO--搜索引擎优化]]></title>
    <url>%2FSEO-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SEO(Search English Optimization)，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 SEO简介意义为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望百度等搜索引擎能多多我们收录精心制作后的网站，并且在别人访问时网站能排在前面。 分类分为白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO。 前端SEO网站结构布局优化一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬。在网站结构优化方面，应提倡扁平化结构。 控制首页链接数量网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。因此对于中小型企业网站，建议首页链接在100个以内，链接的性质可以包含页面导航、底部导航、锚文字链接等等，注意链接要建立在用户的良好体验和引导用户获取信息的基础之上。 扁平化的目录层次尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。扁平化的目录结构，比如：“植物”–&gt; “水果” –&gt; “苹果”、“桔子”、“香蕉”，通过3级就能找到香蕉了。 导航优化导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，&lt;img&gt;标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。 网站的结构布局 页面头部：logo及主导航，以及用户的信息。 页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。 页面底部：版权信息和友情链接。 特别注意：分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。 控制页面的大小减少http请求，提高网站的加载速度。一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。 网页代码优化 &lt;title&gt;：标题，只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的&lt;title&gt;标题中不要设置相同的内容。 &lt;meta keywords&gt;：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。 &lt;meta description&gt;：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 &lt;body&gt;中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6是用于标题类的，&lt;nav&gt;标签是用来设置页面主导航的等。 &lt;a&gt;：页内链接，要加“title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上rel=”nofollow”属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。 &lt;h1&gt;：“蜘蛛” 认为它最重要，若不喜欢&lt;h1&gt;的默认样式可以通过CSS设置。尽量做到正文标题用&lt;h1&gt;标签，副标题用&lt;h2&gt;标签, 而其它地方不应该随便乱用 h 标题标签。 &lt;br&gt;标签：只用于文本内容的换行 表格应该使用&lt;caption&gt;表格标题标签 &lt;img&gt;：应使用 “alt” 属性加以说明 &lt;strong&gt;、&lt;em&gt;: 需要强调时使用。&lt;strong&gt;标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，&lt;em&gt;标签强调效果仅次于标签。&lt;b&gt;、&lt;i&gt;标签: 只是用于显示效果时使用，在SEO中不会起任何效果。 文本缩进不要使用特殊符号&nbsp; 应当使用CSS进行设置。 版权符号不要使用特殊符号 &copy; 可以直接使用输入法或复制此处符号：©。 巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。 重要内容不要用JS输出，因为“蜘蛛”不认识 尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容 谨慎使用display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。 js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。 注意： 本文摘录自CSDN博主「徐小七七」的原创文章原文链接：https://blog.csdn.net/xustart7720/article/details/79960591]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用js方法小结]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8js%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在写网页的过程中经常会用到一些特定功能的函数，本文记录一些常用的js方法，以便随时查用。使用时请根据实际情况对函数进行修改。 获取地址栏参数12345678910function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配 var context = ""; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == "" || context == "undefined" ? "" : context; &#125; 验证手机号12345678function checkTel(str)&#123; var myreg=/^[1][0-9]&#123;10&#125;$/; if(!myreg.test(str))&#123; return false &#125;else&#123; return true &#125;&#125; 移动端rem布局12345678910111213(function(doc, win) &#123; var de = doc.documentElement, re = 'orientationchange' in window ? 'orientationchange': 'resize', recalc = function() &#123; var cw = de.clientWidth; if (!cw) return; de.style.fontSize = cw &gt;= 750 ? '100px': 100 * (cw / 750) + 'px'; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(re, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 唤起app1234567891011121314151617181920212223242526272829303132333435363738//创建baseSchemevar baseSchemeAdr = "Andeoid唤起协议";var baseSchemeIOS = "IOS唤起协议";var downLoadUrl = "下载APP的url";var u = navigator.userAgent;var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端//打开APPvar openApp=function()&#123; if(isiOS)&#123; //判断是否是ios,具体的判断函数自行百度 window.location.href = baseSchemeIOS; var loadDateTime = Date.now(); setTimeout(function () &#123; var timeOutDateTime = Date.now(); if (timeOutDateTime - loadDateTime &lt; 4000) &#123; window.location.href = downLoadUrl; &#125; &#125;, 3000); &#125;else if(isAndroid)&#123; var loadDateTime = Date.now(); //判断是否是android document.getElementById('openapp-btn').href = baseSchemeAdr; document.getElementById('openapp-btn').click(); setTimeout(function () &#123; var timeOutDateTime = Date.now(); if (timeOutDateTime - loadDateTime &lt; 2000) &#123; window.location.href = downLoadUrl; &#125; &#125;, 1500); &#125;else&#123; //主要是给winphone的用户准备的 window.location.href = baseSchemeIOS; setTimeout(function () &#123; window.location.href = downLoadUrl; &#125;, 500); &#125;&#125; cookie的相关操作设置cookie12345678910111213/*c_name : 传入的键（str） value : 传入的值（str） expiredays : 有效期 / 天为单位(number)*/function setCookie (c_name,value,expiredays) &#123; var exdate=new Date() exdate.setDate(exdate.getDate()+expiredays) document.cookie=c_name+ "=" +escape(value)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString());&#125;;var token = 'asds4145451211122-41';setCookie('token',token,1) 获取cookie123456789101112131415161718//c_name : 获取的cookie键（str）function getCookie (c_name) &#123; if (document.cookie.length&gt;0) &#123; var c_start=document.cookie.indexOf(c_name + "=") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 var c_end=document.cookie.indexOf(";",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return ""&#125;;var token = getCookie('token');alert(token) 删除Cookie12345678910//name : 要删除的cookie键(str)function delCookie (name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString();&#125;delCookie('token') 时间格式化1234567891011121314151617181920Date.prototype.Format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;;var temp = 1570684251000;console.log(new Date(temp).Format("yyyy-MM-dd hh:mm:ss"))// 输出结果为：2019-10-10 13:10:51console.log(new Date(temp).Format("yyyy/MM/dd hh:mm:ss"))// 输出结果为：2019/10/10 13:10:51 倒计时已知开始时间和结束时间的倒计时12345678910111213141516171819202122232425262728293031/*用于计算未来某天距离当前的倒计时id--倒计时的元素idendDateStr-- 截止时间*/function timeDown(startDate,endDateStr) &#123; //结束时间 var endDate = new Date(endDateStr); //当前时间 var startDate = new Date(startDate); //相差的总秒数 var totalSeconds = parseInt((endDate - startDate) / 1000); //天数 var days = Math.floor(totalSeconds / (60 * 60 * 24)); //取模（余数） var modulo = totalSeconds % (60 * 60 * 24); //小时数 var hours = Math.floor(modulo / (60 * 60)); modulo = modulo % (60 * 60); //分钟 var minutes = Math.floor(modulo / 60); //秒 var seconds = modulo % 60; // 展示到页面中：此处不做处理，根据实际情况进行修改 //延迟一秒执行自己 setTimeout(function () &#123; timeDown(startDate, endDateStr); &#125;, 1000)&#125; 获取短信验证码类（指定时间）的倒计时123456789101112131415// id--获取验证码的按钮function codeTime(id)&#123; $(id).attr('disabled','disabled').css('opacity',.6); var time = 60;// 以60s为例 $(id).html(time + 's后重新发送'); var t = setInterval(function()&#123; time --; if(time == 0)&#123; clearInterval(t); $(id).removeAttr('disabled').css('opacity',1).html('发送验证码'); &#125;else&#123; $(id).html(time + 's后重新发送'); &#125; &#125;,1000)&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app内嵌h5页面问题小结]]></title>
    <url>%2Fapp%E5%86%85%E5%B5%8Ch5%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原生app能内嵌H5，是因为有了webview这个app内嵌浏览器视图，使得我们可以开发html然后加载到app中（原理几乎跟pc端请求、加载、渲染是一样的），一般的当我们将h5开发好后就可以有两种方式请求到原生app中，一个是将html代码放到服务器上，一个是放在当前app项目目录中本地请求（一般用于调试）。 app与内嵌h5页面实现交互通过函数的调用实现。app调用js方法时前端提供方法名及参数即可，js调用app的方法时需区分设备是ios还是安卓，然后分别调用。 判断是ios还是安卓123456var ua = navigator.userAgent.toLowerCase();if(/iphone|ipad|ipod/.test(ua))&#123; console.log('IOS')&#125;else&#123; console.log('Android')&#125; 调用app原生方法示例具体如何使用应以实际ios和安卓人员提供的方法为准，以下示例仅供参考。 12345678910111213141516function jumpCustom(id)&#123; if(/iphone|ipad|ipod/.test(ua))&#123; if(id)&#123; window.webkit.messageHandlers.openCustomView.postMessage([id]); &#125;else&#123; window.webkit.messageHandlers.openCustomView.postMessage(null); &#125; &#125;else&#123; if(id)&#123; window.android.openCustomView(id); &#125;else&#123; window.android.openCustomView(); &#125; &#125;&#125; ios内嵌h5页面遇到的问题时间转为毫秒时不支持“2018-08-30”的格式1234// 报错，NANnew Date('2018-08-30').getTime()// 需转换成 '/'new Date('2018-08-30'.replace(/-/g,'/')).getTime() ios在内嵌网页的url后带中文参数传参时如果有中文参数会导致接收到的参数被编码或者页面空白，此时需处理所传参数。在h5页面中做如下处理： 1234567891011121314151617//得到页面的urlvar initUrl = window.location.href;//对含有中文的url进行解码,注意是两次解码var URL_decode = decodeURI(decodeURI(initUrl));// 获取地址栏参数function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配 var context = ""; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == "" || context == "undefined" ? "" : context; &#125;// url传参时获取初始值var initTit = decodeURI(GetQueryString('title'));]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mip改造小记]]></title>
    <url>%2Fmip%E6%94%B9%E9%80%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MIP（Mobile Instant Pages - 移动网页加速器），是一套应用于移动网页的开放性技术标准。通过提供 MIP-HTML 规范、MIP-JS 运行环境以及 MIP-Cache 页面缓存系统，实现移动网页加速。 mip简介MIP 主要由三部分组成： MIP-HTML：基于 HTML 中的基础标签制定了全新的规范，通过对一部分基础标签的使用限制或功能扩展，使 HTML 能够展现更加丰富的内容。 MIP-JS：可以保证 MIP-HTML 页面的快速渲染。 MIP-Cache：用于实现 MIP 页面的高速缓存，从而进一步提高页面性能。 mip页面改造mip的页面改造需要符合mip规范，大致有以下几点： css： mip页面中不允许使用行内样式 如果需要补充样式，仅允许在 &lt;head&gt;标签中使用 &lt;style mip-custom&gt;&lt;/style&gt; ，且只可出现一次 js: mip页面中不允许使用自定义的js，也不允许引入除了官方组件（包括站长组件）之外的js 所有页面 必须 在 &lt;body&gt; 的 最后 编写或引用 mip 相关的 js 如有需要，可使用 mip-script 标签进行少量js的书写 html: 所有页面 必须 包含 &lt;html&gt;, &lt;head&gt;, &lt;body&gt; a 标签的href属性为必填，锚点定位仍可用，但不允许使用 ‘javascript:;’ 之类，不允许使用 target 属性，具体可参看官网要求 img 标签需替换为 mip-img ,同时应设定好图片的宽高属性（width 、height） form 等表单元素的使用需参看 mip 官网说明 图片轮播、tab切换等功能，均可通过 mip 提供的官方组件实现本文仅列常见几点以供参考，具体规范请详读官网。 mip开发站长组件fork mip的官方站长组件仓库 浏览器进入 GitHub 中 MIP 官方组件代码仓库，点击右上角的 fork 按钮，fork 完成后，在你 GitHub 主页下的 Repositories 下会多出一个 mip2-extensions-platform 仓库 新建文件夹 mip-project，进入该文件夹右键 -&gt; Git Bash Here -&gt; git clone https://项目地址tips: git窗口中复制快捷键:ctrl + insert 粘贴：shift + insert 创建开发项目 mip-project 文件夹下进入 sites ，路径下输入cmd打开命令窗口，下载 mip2-cli 1npm install mip2-cli -g 创建项目 12mip2 init 项目名称（以cngold.org为例）cd cngold.org 新增组件 1mip2 add mip-jt-stock 调试预览 1mip2 dev 检验 1mip2 validate -c ./components 检查js规范：根据提示进行规范修改 1234// 安装eslintnpm install -g eslint // 进入索要检测的js文件所在目录eslint mip-jt-stock.js 提交 进入 mip-project 目录，添加仓库 12345678// 对比本地仓库与线上仓库的改动git status// 查看自己当前git仓库的configure,origin代表自己的仓库git remote -v// 添加新的远程仓库git remote add mip2-upstream（仓库名，可自定义） 原项目地址（即mip官方站长组件库对应地址）// 再次查看当前git仓库的configure，若出现mip2-upstream（或自定义的仓库名），则为添加成功git remote -v 提交代码 123456// . 代表添加所有改动文件，也可自行指定所要提交的文件git add .// 注释说明git commit -m &apos;注释内容&apos;// 提交到自己的仓库git push origin 发起 Pull Request，申请合并到官方站长组件库 打开自己的 github ，找到fork的项目 进入项目， new pull request -&gt; create pull create，添加说明内容并提交审核（具体提交规范参看官网） Pull request 提交后，会自动触发持续集成的任务，如代码规范检查、部署预览等，在 Conversation 选项卡可以看到实时状态。如果有不通过的，需要再次修改提交，确保所有检查项都成功通过，官方才能审核合入 并不是每次提交都需要 pull request ，在同一分支下 push 代码时，所有的 commits 都会被自动追加到 pull request 后面 在 marge 到原项目仓库地址后，即为该条 pull request 关闭，再次提交时需重新发起。 mip-cacheMIP-Cache 给所有符合规范的 MIP 页面提供 CDN 缓存服务，能够主动的提高页面加载速度，为使用 MIP-Cache 服务的页面上的图片、CSS 文件等资源提供缓存服务，这样能做到所有 HTTP 请求来自于同源，能够加速加载速度，并且缓存后的页面都是 HTTPS 的，安全性更高。其他描述请参看官网。 如何快速更新 mip-cache 登录百度账号之后，进入 https://ziyuan.baidu.com/mip/index ，选择对应站点 获取Authkey http站点接口调用地址：http://c.mipcdn.com/update-ping/c/urlhttps站点接口调用地址：http://c.mipcdn.com/update-ping/c/s/url注：https://mip.xxx.com/ 和 https://mip.xxx.com在MIPCache中属于不同的URL链接，请务必保证mip数据中提交的URL链接和百度收录链接保持一致。 运行清除缓存的代码，以php为例，本地开启 WAMP ，进入 www 目录，将示例代码放入页面，进入 localhost 访问页面，是否清除缓存成功请参看百度（status 为0） 1234567891011$api = 'http://c.mipcdn.com/update-ping/c/';$postData = 'key=348d7e884c581428395cec452bc32032';$url = $api.urlencode('m.120ask.com/askg/bd_detail/39372771');$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);$result = curl_exec($ch);curl_close($ch);echo $result;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>mip</tag>
      </tags>
  </entry>
</search>
